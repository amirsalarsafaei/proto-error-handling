package helloworld

import (
	"context"
	"errors"

	helloworldPb "github.com/amirsalarsafaei/proto-error-handling/autogenerated/go/helloworld"
	"google.golang.org/genproto/googleapis/rpc/errdetails"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type userService struct {
	helloworldPb.UnimplementedUserServiceServer
	userRepo UserRepository
}

func (s *userService) CreateUser(
	ctx context.Context,
	request *helloworldPb.CreateUserRequest,
) (*helloworldPb.CreateUserResponse, error) {
	var err error

	user := User{
		Username: request.GetUsername(),
		Email:    request.GetEmail(),
	}

	if err = user.Validate(); err != nil {
		st := status.New(codes.InvalidArgument, "Invalid user data")

		var violations []*errdetails.BadRequest_FieldViolation

		switch err {
		case ErrEmptyUsername:
			violations = append(violations, &errdetails.BadRequest_FieldViolation{
				Field:       "username",
				Description: "Username cannot be empty",
			})
		case ErrEmptyEmail:
			violations = append(violations, &errdetails.BadRequest_FieldViolation{
				Field:       "email",
				Description: "Email cannot be empty",
			})
		case ErrInvalidEmail:
			violations = append(violations, &errdetails.BadRequest_FieldViolation{
				Field:       "email",
				Description: "Invalid email format",
			})
		case ErrUsernameTooLong:
			violations = append(violations, &errdetails.BadRequest_FieldViolation{
				Field:       "username",
				Description: "Username exceeds maximum length",
			})
		}

		br := &errdetails.BadRequest{FieldViolations: violations}
		st, err = st.WithDetails(br)
		if err != nil {
			return nil, status.Error(codes.Internal, "Failed to add error details")
		}
		return nil, st.Err()
	}

	if user, err = s.userRepo.AddUser(user); err != nil {
		switch {
		case errors.Is(err, ErrDuplicateEmail):
			st := status.New(codes.AlreadyExists, "User already exists")
			br := &errdetails.BadRequest{
				FieldViolations: []*errdetails.BadRequest_FieldViolation{{
					Field:       "email",
					Description: "Email already in use",
				}},
			}
			st, err = st.WithDetails(br)
			if err != nil {
				return nil, status.Error(codes.Internal, "Failed to add error details")
			}
			return nil, st.Err()
		case errors.Is(err, ErrDuplicateUsername):
			st := status.New(codes.AlreadyExists, "User already exists")
			br := &errdetails.BadRequest{
				FieldViolations: []*errdetails.BadRequest_FieldViolation{{
					Field:       "username",
					Description: "Username already in use",
				}},
			}
			st, err = st.WithDetails(br)
			if err != nil {
				return nil, status.Error(codes.Internal, "Failed to add error details")
			}
			return nil, st.Err()
		default:
			return nil, status.Error(codes.Internal, "Failed to create user")
		}
	}

	return &helloworldPb.CreateUserResponse{
		UserId: user.UUID.String(),
		Status: helloworldPb.UserStatus_USER_STATUS_PENDING,
	}, nil
}

func (s *userService) CreateUserAlt(
	ctx context.Context,
	request *helloworldPb.CreateUserRequest,
) (*helloworldPb.CreateUserAltResponse, error) {
	var err error
	user := User{
		Username: request.GetUsername(),
		Email:    request.GetEmail(),
	}

	if err = user.Validate(); err != nil {
		var code string
		var message string

		switch err {
		case ErrEmptyUsername:
			code = "VALIDATION_EMPTY_USERNAME"
			message = "Username cannot be empty"
		case ErrEmptyEmail:
			code = "VALIDATION_EMPTY_EMAIL"
			message = "Email cannot be empty"
		case ErrInvalidEmail:
			code = "VALIDATION_INVALID_EMAIL"
			message = "Invalid email format"
		case ErrUsernameTooLong:
			code = "VALIDATION_USERNAME_TOO_LONG"
			message = "Username exceeds maximum length"
		default:
			code = "VALIDATION_FAILED"
			message = "Invalid input data"
		}

		errorInfo := &helloworldPb.CreateUserAltResponse_Error{
			Error: &helloworldPb.ErrorDetails{
				Code:    code,
				Message: message,
			},
		}
		return &helloworldPb.CreateUserAltResponse{
			Result: errorInfo,
		}, nil
	}

	if user, err = s.userRepo.AddUser(user); err != nil {
		switch {
		case errors.Is(err, ErrDuplicateEmail):
			errorInfo := &helloworldPb.CreateUserAltResponse_Error{
				Error: &helloworldPb.ErrorDetails{
					Code:    "DUPLICATE_EMAIL",
					Message: "Email is already in use",
				},
			}
			return &helloworldPb.CreateUserAltResponse{
				Result: errorInfo,
			}, nil
		case errors.Is(err, ErrDuplicateUsername):
			errorInfo := &helloworldPb.CreateUserAltResponse_Error{
				Error: &helloworldPb.ErrorDetails{
					Code:    "DUPLICATE_USERNAME",
					Message: "Username is already in use",
				},
			}
			return &helloworldPb.CreateUserAltResponse{
				Result: errorInfo,
			}, nil

		default:
			errorInfo := &helloworldPb.CreateUserAltResponse_Error{
				Error: &helloworldPb.ErrorDetails{
					Code:    "INTERNAL_ERROR",
					Message: "Failed to create user",
				},
			}
			return &helloworldPb.CreateUserAltResponse{
				Result: errorInfo,
			}, nil
		}
	}

	return &helloworldPb.CreateUserAltResponse{
		Result: &helloworldPb.CreateUserAltResponse_Success{
			Success: &helloworldPb.UserData{
				UserId: user.UUID.String(),
				Status: helloworldPb.UserStatus_USER_STATUS_PENDING,
			},
		},
	}, nil
}

func NewUserService(userRepo UserRepository) helloworldPb.UserServiceServer {
	return &userService{
		userRepo: userRepo,
	}
}
